<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Download Stats Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .toggle-switch {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            padding: 10px;
        }

        .toggle-label {
            cursor: pointer;
            flex-basis: calc(10%); /* Subtract gap size */
            text-align: center;
        }

        .toggle-label input[type="radio"] {
            display: none;
        }

        .toggle-label input[type="radio"] + span {
            display: block;
            padding: 8px 12px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .toggle-label input[type="radio"]:checked + span {
            background-color: #4CAF50;
            color: white;
            border: 1px solid #4CAF50;
        }
    </style>
</head>
<body>
<h1>Version Selector</h1>
<select id="versionSelector"></select>
<h2>Show Last</h2>
<div class="toggle-switch">
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="7">
        <span>7 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="28">
        <span>28 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="30">
        <span>30 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="60">
        <span>60 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="90">
        <span>90 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="180">
        <span>6 months</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="365">
        <span>1 year</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="1825">
        <span>5 years</span>
    </label>
</div>
<h1>All downloads by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="platformChart"></canvas>
</div>
<h1>Installer downloads only by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="installerChart"></canvas>
</div>
<h1>Updates only by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="updaterChart"></canvas>
</div>
<h1>Individual Assets</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="downloadsChart"></canvas>
</div>
<script>
    async function plotData() {
        let timePeriod = localStorage.getItem("HistoryViewWindow") || "30";
        let currentlyPlottingData;
        const radioButtons = document.querySelectorAll('input[name="timeDuration"]');
        radioButtons.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    console.log(`Selected Duration: ${this.value} days`);
                    localStorage.setItem("HistoryViewWindow", this.value);
                    timePeriod = this.value;
                    if(currentlyPlottingData){
                        updateCharts(currentlyPlottingData);
                    }
                }
            });
        });

        // Function to get the currently selected option
        function getSelectedOption() {
            const selectedRadio = document.querySelector('input[name="timeDuration"]:checked');
            return selectedRadio ? selectedRadio.value : null;
        }

        // Function to set a selected option
        function setSelectedOption(value) {
            const radioToSelect = document.querySelector(`input[name="timeDuration"][value="${value}"]`);
            if (radioToSelect) {
                radioToSelect.checked = true;
                console.log(`Set Duration to: ${value} days`);
            }
        }

        setSelectedOption(timePeriod);
        function trimAndReverseVersionData(data, days) {
            data = structuredClone(data);
            const trimmedData = {};

            const versionData = data;
            const { timeSeries } = versionData;
            const trimIndex = Math.max(timeSeries.length - days, 0); // Calculate index to start slicing from

            // Create a new object for the version, initializing with a trimmed timeSeries
            // the array is sorted in time latest at start, so we need to reverse it too.
            trimmedData.timeSeries = timeSeries.reverse().slice(trimIndex);

            // Go through each key except timeSeries in the version data
            Object.keys(versionData).forEach(key => {
                if (!["timeSeries", "publishDate"].includes(key)) {
                    // Trim each array to the same length as the new timeSeries
                    trimmedData[key] = versionData[key].reverse().slice(trimIndex);
                }
            });

            return trimmedData;
        }

        const DOWNLOAD_HISTORY_URL = "https://public-stats.phcode.io/generated/download_history.json";
        async function getCurrentHistoryData() {
            try{
                const fetchedData = await fetch(DOWNLOAD_HISTORY_URL);
                return await fetchedData.json();
            } catch (e) {
                console.error("No previous data", e);
            }
            return null;
        }
        let downloadsChart, platformChart, installerChart, updaterChart;
        const historyData = await getCurrentHistoryData();
        const data = historyData.prodReleaseHistory;

        const versionSelector = document.getElementById('versionSelector');
        const versions = Object.keys(data);
        let latestVersion = versions[0];
        versions.forEach(version => {
            const option = document.createElement('option');
            option.value = version;
            option.textContent = version;
            versionSelector.appendChild(option);
            if(version > latestVersion){
                latestVersion = version;
            }
        });
        // Initialize charts with the first version selected
        versionSelector.addEventListener('change', () => {
            updateCharts(data[versionSelector.value]);
        });
        console.log("latest Version", latestVersion);
        versionSelector.value = latestVersion;
        updateCharts(data[latestVersion]);
        function updateCharts(inputData) {
            currentlyPlottingData = inputData;
            const data = trimAndReverseVersionData(inputData, parseInt(timePeriod));
            // Calculate platform aggregates
            function sumDownloads(dataArray) {
                return dataArray[0].map((_, index) => dataArray.reduce((sum, current) => sum + current[index], 0));
            }

            const linuxInstaller = sumDownloads([data.LINUX_X64_GLIBC_2_31_INSTALLER, data.LINUX_X64_GLIBC_2_35_INSTALLER]);
            const macInstaller = sumDownloads([data.MAC_M1_INSTALLER, data.MAC_X64_INSTALLER]);
            const windowsInstaller = sumDownloads([data.WINDOWS_X64_INSTALLER]);

            const macUpdater = sumDownloads([data.MAC_M1_UPDATER, data.MAC_X64_UPDATER]);
            const windowsUpdater = sumDownloads([data.WINDOWS_X64_UPDATER]);

            const alMac = sumDownloads([macInstaller, macUpdater]);
            const alWin = sumDownloads([windowsInstaller, windowsUpdater]);

            const ctx1 = document.getElementById('downloadsChart').getContext('2d');
            if(downloadsChart){
                downloadsChart.destroy();
            }
            downloadsChart = new Chart(ctx1, {
                type: 'line',
                data: createChartData(data, ''),
                options: createChartOptions()
            });

            const ctx2 = document.getElementById('platformChart').getContext('2d');
            if(platformChart){
                platformChart.destroy();
            }
            platformChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        // in linux we cant distinguish between installs and updates, so we just use linuxInstaller
                        { label: 'Linux', data: linuxInstaller, borderColor: 'orange', tension: 0.1 },
                        { label: 'Mac', data: alMac, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows', data: alWin, borderColor: 'blue', tension: 0.1 },
                        { label: 'Total', data: data.totalDownloads, borderColor: '#000000', tension: 0.1 }
                    ]
                },
                options: createChartOptions()
            });

            const ctx3 = document.getElementById('installerChart').getContext('2d');
            if(installerChart){
                installerChart.destroy();
            }
            installerChart = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        { label: 'Linux', data: linuxInstaller, borderColor: 'orange', tension: 0.1 },
                        { label: 'Mac', data: macInstaller, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows', data: windowsInstaller, borderColor: 'blue', tension: 0.1 },
                    ]
                },
                options: createChartOptions()
            });

            const ctx4 = document.getElementById('updaterChart').getContext('2d');
            if(updaterChart){
                updaterChart.destroy();
            }
            updaterChart = new Chart(ctx4, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        { label: 'Mac Updaters', data: macUpdater, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows Updaters', data: windowsUpdater, borderColor: 'blue', tension: 0.1 }
                    ]
                },
                options: createChartOptions()
            });

            function createChartData(data, labelPrefix) {
                return {
                    labels: data.timeSeries,
                    datasets: Object.keys(data).filter(key => key !== "timeSeries" && key !== "publishDate").map(key => ({
                        label: `${labelPrefix} - ${key.replace(/_/g, ' ')}`,
                        data: data[key],
                        borderColor: getRandomColor(),
                        tension: 0.1
                    }))
                };
            }

            function createChartOptions() {
                return {
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false
                };
            }

            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
        }
    }
    plotData();
</script>
</body>
</html>

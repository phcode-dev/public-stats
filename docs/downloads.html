<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Download Stats Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src=https://unpkg.com/compare-versions/lib/umd/index.js></script>
    <style>
        .toggle-switch {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            padding: 10px;
        }

        .toggle-label {
            cursor: pointer;
            flex-basis: calc(10%); /* Subtract gap size */
            text-align: center;
        }

        .toggle-label input[type="radio"] {
            display: none;
        }

        .toggle-label input[type="radio"] + span {
            display: block;
            padding: 8px 12px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .toggle-label input[type="radio"]:checked + span {
            background-color: #4CAF50;
            color: white;
            border: 1px solid #4CAF50;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 100px; /* Increased width to accommodate labels */
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            display: flex;
            align-items: center;
            justify-content: right;
            padding: 0 10px;
            color: black;
            font-size: 12px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: limegreen;
            justify-content: left;
        }

        input:checked + .slider:before {
            transform: translateX(56px); /* Adjusted for wider switch */
        }

        .label {
            pointer-events: none; /* Disable events on labels to avoid interference */
        }

        .daily {
            display: block;
            order: 2; /* Ensures it goes to the right when unchecked */
        }

        .aggregate {
            display: none;
        }

        input:checked + .slider .aggregate {
            display: block;
            order: 1; /* Ensures it goes to the left when checked */
        }

        input:checked + .slider .daily {
            display: none;
        }

    </style>
</head>
<body>
<h1>Version Selector</h1>
<select id="versionSelector"></select>
<label class="switch">
    <input type="checkbox" id="toggleButton">
    <span class="slider">
            <span class="label daily">Daily</span>
            <span class="label aggregate">Aggregate</span>
        </span>
</label>
<h2>Show Last</h2>
<div class="toggle-switch">
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="7">
        <span>7 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="28">
        <span>28 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="30">
        <span>30 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="60">
        <span>60 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="90">
        <span>90 days</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="180">
        <span>6 months</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="365">
        <span>1 year</span>
    </label>
    <label class="toggle-label">
        <input type="radio" name="timeDuration" value="1825">
        <span>5 years</span>
    </label>
</div>
<h1>All downloads by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="platformChart"></canvas>
</div>
<h1>Installer downloads only by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="installerChart"></canvas>
</div>
<h1>Updates only by OS</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="updaterChart"></canvas>
</div>
<h1>Individual Assets</h1>
<div style="width:80%; margin: 20px auto; height: 50vh;">
    <canvas id="downloadsChart"></canvas>
</div>
<script>
    async function plotData() {
        let timePeriod = localStorage.getItem("HistoryViewWindow") || "30";
        if(!localStorage.getItem("isAggregateMode")){
            localStorage.setItem("isAggregateMode", "yes");
        }
        let isAggregateMode = (localStorage.getItem("isAggregateMode") === "yes");
        let currentlyPlottingData;
        const radioButtons = document.querySelectorAll('input[name="timeDuration"]');
        radioButtons.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    console.log(`Selected Duration: ${this.value} days`);
                    localStorage.setItem("HistoryViewWindow", this.value);
                    timePeriod = this.value;
                    if(currentlyPlottingData){
                        updateCharts(currentlyPlottingData);
                    }
                }
            });
        });

        // Function to get the currently selected option
        function getSelectedOption() {
            const selectedRadio = document.querySelector('input[name="timeDuration"]:checked');
            return selectedRadio ? selectedRadio.value : null;
        }

        // Function to set a selected option
        function setSelectedOption(value) {
            const radioToSelect = document.querySelector(`input[name="timeDuration"][value="${value}"]`);
            if (radioToSelect) {
                radioToSelect.checked = true;
                console.log(`Set Duration to: ${value} days`);
            }
        }

        document.getElementById('toggleButton').addEventListener('change', function() {
            console.log(`Switched to: ${this.checked ? 'Aggregate' : 'Daily'}`);
            isAggregateMode = this.checked;
            setAggregateMode(isAggregateMode);
            if(currentlyPlottingData){
                updateCharts(currentlyPlottingData);
            }
        });

        function setAggregateMode(isAggregate) {
            const toggle = document.getElementById('toggleButton');
            toggle.checked = isAggregate; // true for 'Aggregate', false for 'Daily'
            localStorage.setItem("isAggregateMode", isAggregate ? "yes" : "no");
        }
        setAggregateMode(isAggregateMode);

        setSelectedOption(timePeriod);

        function computeDailyDownloads(stats) {
            const dailyDownloads = [];
            if(stats.length >= 1){
                dailyDownloads.push(stats[0]);
            }
            for (let i = 1; i < stats.length; i++) {
                dailyDownloads.push(stats[i] - stats[i - 1]);
            }
            return dailyDownloads;
        }

        function trimAndReverseVersionData(data, days, computeDailyData, version) {
            data = structuredClone(data);
            const trimmedData = {};

            const versionData = data;
            const { timeSeries } = versionData;

            if(timeSeries.length === 1 || !timeSeries.length){
                // if there is only 1 data point, this is likley a new release and we will
                computeDailyData = false;
            }
            let shouldTrimFirstElem = false;
            if(computeDailyData && (timeSeries.length > days || compareVersions.satisfies(version, "<=3.8.8"))){
                // if we have more stats, then we add one more day so that we can compute daily downloads
                // For eg, if we are computing 7 day daily downloads, and we have 8 days stats, we compute the 7th
                // day downloads by subtracting 7th dya amd 8th day downloads. but the array will have 8 entries,
                // the first being the absolute 8th day download count, which we should trim.

                // for versions smaller than 3.8.8, we started creating history data mid way and we need to trim the
                // first element which is the aggregate of several months of downloads, not what we intend for daily
                // downloads
                days = days + 1;
                shouldTrimFirstElem = true;
            }
            const trimIndex = Math.max(timeSeries.length - days, 0); // Calculate index to start slicing from

            // Create a new object for the version, initializing with a trimmed timeSeries
            // the array is sorted in time latest at start, so we need to reverse it too.
            trimmedData.timeSeries = timeSeries.reverse().slice(trimIndex);
            if(shouldTrimFirstElem){
                trimmedData.timeSeries = trimmedData.timeSeries.slice(1);
            }

            // Go through each key except timeSeries in the version data
            Object.keys(versionData).forEach(key => {
                if (!["timeSeries", "publishDate"].includes(key)) {
                    // Trim each array to the same length as the new timeSeries
                    trimmedData[key] = versionData[key].reverse().slice(trimIndex);
                    if(computeDailyData){
                        trimmedData[key] = computeDailyDownloads(trimmedData[key]);
                        if(shouldTrimFirstElem){
                            trimmedData[key] = trimmedData[key].slice(1);
                        }
                    }
                }
            });

            return trimmedData;
        }

        const DOWNLOAD_HISTORY_URL = "https://public-stats.phcode.io/generated/download_history.json";
        async function getCurrentHistoryData() {
            try{
                const fetchedData = await fetch(DOWNLOAD_HISTORY_URL);
                return await fetchedData.json();
            } catch (e) {
                console.error("No previous data", e);
            }
            return null;
        }
        let downloadsChart, platformChart, installerChart, updaterChart;
        const historyData = await getCurrentHistoryData();
        const data = historyData.prodReleaseHistory;

        const versionSelector = document.getElementById('versionSelector');
        const versions = Object.keys(data);
        let latestVersion = versions[0];
        versions.forEach(version => {
            const option = document.createElement('option');
            option.value = version;
            option.textContent = version;
            versionSelector.appendChild(option);
            if(version > latestVersion){
                latestVersion = version;
            }
        });
        // Initialize charts with the first version selected
        versionSelector.addEventListener('change', () => {
            updateCharts(data[versionSelector.value]);
        });
        console.log("latest Version", latestVersion);
        versionSelector.value = latestVersion;
        updateCharts(data[latestVersion]);
        function updateCharts(inputData) {
            currentlyPlottingData = inputData;
            const data = trimAndReverseVersionData(inputData, parseInt(timePeriod), !isAggregateMode, versionSelector.value);
            // Calculate platform aggregates
            function sumDownloads(dataArray) {
                return dataArray[0].map((_, index) => dataArray.reduce((sum, current) => sum + current[index], 0));
            }

            const linuxInstaller = sumDownloads([data.LINUX_X64_GLIBC_2_31_INSTALLER, data.LINUX_X64_GLIBC_2_35_INSTALLER]);
            const macInstaller = sumDownloads([data.MAC_M1_INSTALLER, data.MAC_X64_INSTALLER]);
            const windowsInstaller = sumDownloads([data.WINDOWS_X64_INSTALLER]);

            const macUpdater = sumDownloads([data.MAC_M1_UPDATER, data.MAC_X64_UPDATER]);
            const windowsUpdater = sumDownloads([data.WINDOWS_X64_UPDATER]);

            const alMac = sumDownloads([macInstaller, macUpdater]);
            const alWin = sumDownloads([windowsInstaller, windowsUpdater]);

            const ctx1 = document.getElementById('downloadsChart').getContext('2d');
            if(downloadsChart){
                downloadsChart.destroy();
            }
            downloadsChart = new Chart(ctx1, {
                type: 'line',
                data: createChartData(data, ''),
                options: createChartOptions()
            });

            const ctx2 = document.getElementById('platformChart').getContext('2d');
            if(platformChart){
                platformChart.destroy();
            }
            platformChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        // in linux we cant distinguish between installs and updates, so we just use linuxInstaller
                        { label: 'Linux', data: linuxInstaller, borderColor: 'orange', tension: 0.1 },
                        { label: 'Mac', data: alMac, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows', data: alWin, borderColor: 'blue', tension: 0.1 },
                        { label: 'Total', data: data.totalDownloads, borderColor: '#000000', tension: 0.1 }
                    ]
                },
                options: createChartOptions()
            });

            const ctx3 = document.getElementById('installerChart').getContext('2d');
            if(installerChart){
                installerChart.destroy();
            }
            installerChart = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        { label: 'Linux', data: linuxInstaller, borderColor: 'orange', tension: 0.1 },
                        { label: 'Mac', data: macInstaller, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows', data: windowsInstaller, borderColor: 'blue', tension: 0.1 },
                    ]
                },
                options: createChartOptions()
            });

            const ctx4 = document.getElementById('updaterChart').getContext('2d');
            if(updaterChart){
                updaterChart.destroy();
            }
            updaterChart = new Chart(ctx4, {
                type: 'line',
                data: {
                    labels: data.timeSeries,
                    datasets: [
                        { label: 'Mac Updaters', data: macUpdater, borderColor: 'silver', tension: 0.1 },
                        { label: 'Windows Updaters', data: windowsUpdater, borderColor: 'blue', tension: 0.1 }
                    ]
                },
                options: createChartOptions()
            });

            function createChartData(data, labelPrefix) {
                return {
                    labels: data.timeSeries,
                    datasets: Object.keys(data).filter(key => key !== "timeSeries" && key !== "publishDate").map(key => ({
                        label: `${labelPrefix} - ${key.replace(/_/g, ' ')}`,
                        data: data[key],
                        borderColor: getRandomColor(),
                        tension: 0.1
                    }))
                };
            }

            function createChartOptions() {
                return {
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false
                };
            }

            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
        }
    }
    plotData();
</script>
</body>
</html>
